// Copyright (c) 2014, StrongLoop Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

#ifndef SRC_GCINFO_BATON_INL_H_
#define SRC_GCINFO_BATON_INL_H_

#include "gcinfo-baton.h"
#include "node_version.h"
#include "queue.h"
#include "v8.h"

namespace strongloop {
namespace agent {
namespace gcinfo {

Baton* Baton::Pop() {
  if (QUEUE_EMPTY(&baton_queue)) {
    return static_cast<Baton*>(0);
  }
  QUEUE* q = QUEUE_HEAD(&baton_queue);
  QUEUE_REMOVE(q);
  return QUEUE_DATA(q, Baton, baton_queue_);
}

Baton* Baton::New(v8::Isolate* isolate,
                  v8::GCType type,
                  v8::GCCallbackFlags flags) {
  Baton* baton = new Baton(isolate, type, flags);
  QUEUE_INSERT_TAIL(&baton_queue, &baton->baton_queue_);
  return baton;
}

Baton::Baton(v8::Isolate* isolate, v8::GCType type, v8::GCCallbackFlags flags)
    : type_(type), flags_(flags) {
#if SL_NODE_VERSION == 8 || SL_NODE_VERSION == 10
  v8::V8::GetHeapStatistics(&heap_statistics_);
#elif SL_NODE_VERSION == 12
  isolate->GetHeapStatistics(&heap_statistics_);
#endif
  QUEUE_INIT(&baton_queue_);
}

v8::GCType Baton::type() const {
  return type_;
}

v8::GCCallbackFlags Baton::flags() const {
  return flags_;
}

v8::HeapStatistics* Baton::heap_statistics() const {
  // HeapStatistics is a getters-only class but its getters aren't marked const.
  return const_cast<v8::HeapStatistics*>(&heap_statistics_);
}

const char* Baton::type_string() const {
  switch (type()) {
#define V(name) case v8::name: return #name
    V(kGCTypeAll);
    V(kGCTypeScavenge);
    V(kGCTypeMarkSweepCompact);
#undef V
  }
  return "UnknownType";
}

const char* Baton::flags_string() const {
  switch (flags()) {
#define V(name) case v8::name: return #name
    V(kNoGCCallbackFlags);
    V(kGCCallbackFlagCompacted);
#if SL_NODE_VERSION == 12
    V(kGCCallbackFlagConstructRetainedObjectInfos);
#endif
#undef V
  }
  return "UnknownFlags";
}

void Baton::Dispose() {
  delete this;
}

}  // namespace gcinfo
}  // namespace agent
}  // namespace strongloop

#endif  // SRC_GCINFO_BATON_INL_H_

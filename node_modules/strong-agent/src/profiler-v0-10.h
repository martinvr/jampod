// Copyright (c) 2014, StrongLoop Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

#ifndef SRC_PROFILER_V0_10_H_
#define SRC_PROFILER_V0_10_H_

#include "strong-agent.h"
#include "v8.h"
#include "v8-profiler.h"

namespace strongloop {
namespace agent {
namespace profiler {

using v8::Arguments;
using v8::Array;
using v8::CpuProfile;
using v8::CpuProfileNode;
using v8::CpuProfiler;
using v8::FunctionTemplate;
using v8::Handle;
using v8::HandleScope;
using v8::Integer;
using v8::Local;
using v8::Number;
using v8::Object;
using v8::String;
using v8::Undefined;
using v8::Value;

Local<Object> ToObject(const CpuProfileNode* node) {
  // Use a helper that caches the property strings.
  struct ToObjectHelper {
    ToObjectHelper() {
      call_uid_sym_ = SL_FIXED_STRING("callUid");
      children_count_sym_ = SL_FIXED_STRING("childrenCount");
      children_sym_ = SL_FIXED_STRING("children");
      function_name_sym_ = SL_FIXED_STRING("functionName");
      line_number_sym_ = SL_FIXED_STRING("lineNumber");
      script_name_sym_ = SL_FIXED_STRING("scriptName");
      self_samples_count_sym_ = SL_FIXED_STRING("selfSamplesCount");
      self_time_sym_ = SL_FIXED_STRING("selfTime");
      total_samples_count_sym_ = SL_FIXED_STRING("totalSamplesCount");
      total_time_sym_ = SL_FIXED_STRING("totalTime");
    }

    bool IsConstructed() const {
      return call_uid_sym_.IsEmpty() == false &&
             children_count_sym_.IsEmpty() == false &&
             children_sym_.IsEmpty() == false &&
             function_name_sym_.IsEmpty() == false &&
             line_number_sym_.IsEmpty() == false &&
             script_name_sym_.IsEmpty() == false &&
             self_samples_count_sym_.IsEmpty() == false &&
             self_time_sym_.IsEmpty() == false &&
             total_samples_count_sym_.IsEmpty() == false &&
             total_time_sym_.IsEmpty() == false;
    }

    Local<Object> ToObject(const CpuProfileNode* node) const {
      HandleScope handle_scope;
      const int children_count = node->GetChildrenCount();

      // Guard against out-of-memory situations, they're not unlikely when
      // the DAG is big.
      Local<Object> o = Object::New();
      if (o.IsEmpty()) return Local<Object>();

      Local<Number> self_samples_count_val =
          Number::New(node->GetSelfSamplesCount());
      if (self_samples_count_val.IsEmpty()) return Local<Object>();

      Local<Number> self_time_val = Number::New(node->GetSelfTime());
      if (self_time_val.IsEmpty()) return Local<Object>();

      Local<Number> total_samples_count_val =
          Number::New(node->GetTotalSamplesCount());
      if (total_samples_count_val.IsEmpty()) return Local<Object>();

      Local<Number> total_time_val = Number::New(node->GetTotalTime());
      if (total_time_val.IsEmpty()) return Local<Object>();

      Local<Integer> call_uid_val =
          Integer::NewFromUnsigned(node->GetCallUid());
      if (call_uid_val.IsEmpty()) return Local<Object>();

      Local<Integer> children_count_val = Integer::New(children_count);
      if (children_count_val.IsEmpty()) return Local<Object>();

      Local<Integer> line_number_val = Integer::New(node->GetLineNumber());
      if (line_number_val.IsEmpty()) return Local<Object>();

      // The next two cannot really fail but the extra checks don't hurt.
      Handle<String> script_name_val = node->GetScriptResourceName();
      if (script_name_val.IsEmpty()) return Local<Object>();

      Handle<String> function_name_val = node->GetFunctionName();
      if (function_name_val.IsEmpty()) return Local<Object>();

      // Field order compatible with strong-cpu-profiler.
      o->Set(children_count_sym_, children_count_val);
      o->Set(call_uid_sym_, call_uid_val);
      o->Set(self_samples_count_sym_, self_samples_count_val);
      o->Set(total_samples_count_sym_, total_samples_count_val);
      o->Set(self_time_sym_, self_time_val);
      o->Set(total_time_sym_, total_time_val);
      o->Set(line_number_sym_, line_number_val);
      o->Set(script_name_sym_, script_name_val);
      o->Set(function_name_sym_, function_name_val);

      Local<Array> children = Array::New(children_count);
      if (children.IsEmpty()) return Local<Object>();
      for (int index = 0; index < children_count; ++index) {
        Local<Object> child = this->ToObject(node->GetChild(index));
        if (child.IsEmpty()) return Local<Object>();
        children->Set(index, child);
      }
      o->Set(children_sym_, children);

      return handle_scope.Close(o);
    }

    Local<String> call_uid_sym_;
    Local<String> children_count_sym_;
    Local<String> children_sym_;
    Local<String> function_name_sym_;
    Local<String> line_number_sym_;
    Local<String> script_name_sym_;
    Local<String> self_samples_count_sym_;
    Local<String> self_time_sym_;
    Local<String> total_samples_count_sym_;
    Local<String> total_time_sym_;
  };

  HandleScope handle_scope;
  ToObjectHelper helper;
  if (helper.IsConstructed() == false) {
    return Local<Object>();  // Out of memory.
  }
  return handle_scope.Close(helper.ToObject(node));
}

Handle<Value> StartCpuProfiling(const Arguments& args) {
  HandleScope handle_scope;
  CpuProfiler::StartProfiling(String::Empty());
  return Undefined();
}

Handle<Value> StopCpuProfiling(const Arguments& args) {
  HandleScope handle_scope;
  const CpuProfile* profile = CpuProfiler::StopProfiling(String::Empty());
  if (profile == NULL) {
    return Undefined();  // Not started or preempted by another profiler.
  }
  Local<Object> top_root = ToObject(profile->GetTopDownRoot());
  CpuProfiler::DeleteAllProfiles();
  if (top_root.IsEmpty() == true) {
    return Undefined();  // Out of memory.
  }
  return handle_scope.Close(top_root);
}

void Initialize(Handle<Object> o) {
  o->Set(SL_FIXED_STRING("startCpuProfiling"),
         FunctionTemplate::New(StartCpuProfiling)->GetFunction());
  o->Set(SL_FIXED_STRING("stopCpuProfiling"),
         FunctionTemplate::New(StopCpuProfiling)->GetFunction());
}

}  // namespace profiler
}  // namespace agent
}  // namespace strongloop

#endif  // SRC_PROFILER_V0_10_H_

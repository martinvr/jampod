process.env.SL_ENV = process.env.SL || 'dev';

var Uhura = require('uhura');
var assert = require('assert');
var config = require('../lib/config');
var http = require('http');
var nf = require('../lib/main');
var tiers = require('../lib/loopbackTiers');

function verifyDataIntegrity(data) {
  assert('loopback_tiers' in data);
  assert('dao' in data.loopback_tiers);
  assert('mean' in data.loopback_tiers.dao);
  assert.equal(typeof(data.loopback_tiers.dao.mean), 'number');
}

// Stub out start and initialize
var oldStart = tiers.prototype.start;
tiers.prototype.start = function() {};
var test = tiers.init();
tiers.prototype.start = oldStart;

// Add some data
test.sample('dao', { ms: Date.now() });
verifyDataIntegrity(test.stats.toJSON());

// Do some cheating to speed up the test
config.tiersInterval = 500;

var loopbackServer;

// Black hole
var uhuraServer = Uhura.createServer(function(c) {
  c.on('createSession', function() {
    c.send('newSession', null, { sessionId: 'foo', appHash: 'bar' });
  });

  c.on('update', function(data) {
    if (!data.loopback_tiers || !data.loopback_tiers.dao) return;
    nf.stop();
    c.disconnect();
    loopbackServer.close(function() {
      uhuraServer.close(function() { verifyDataIntegrity(data) });
    });
  });
}).listen(0, '127.0.0.1', function() {
  // Start profiling
  nf.profile('foo', 'bar', {
    host: this.address().address,
    port: this.address().port,
    quiet: true,
  });

  var loopback = require('loopback');
  var db = loopback.createDataSource({
    connector: loopback.Memory
  });

  // Start an express server and make a request to it
  var Person = loopback.Model.extend('person');
  Person.attachTo(db);

  var app = loopback();
  app.use(loopback.rest());
  app.model(Person);

  // Wrap in http server so it can be closed properly
  loopbackServer = http.createServer(app);
  loopbackServer.listen(0, '127.0.0.1', function() {
    http.get({
      host: this.address().address,
      port: this.address().port,
      path: '/people',
    });
  });
});

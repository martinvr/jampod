function debug (format, args) {
	if (/uhura/.test(process.env.NODEFLY_DEBUG) ) {
		console.log.apply(console, ['UHURA: ' + format].concat(args || []));
	}
}

function verbose(format, args) {
	var args = ['UHURA: ' + format].concat(args || []);
	if (/uhura_verbose/.test(process.env.NODEFLY_DEBUG) ) {
		console.log.apply(console, args);
	}
}

var Uhura = require('uhura')
	, util = require('util')
	, Url = require('url');

var config = require('./config');

function Transport (options) {
	Uhura.Client.call(this);
	this.setMaxListeners(Infinity);
	this.agent = options.agent;
	this.agentVersion = options.agentVersion;
	this.loopbackVersion = options.loopbackVersion;

	this.port = options.port || config.collector.port;
	this.host = options.host || config.collector.host;

  // return without connecting (for tests)
	if (options.noConnect === true) return;

	this.connect(this.port, this.host);
	this.autoReconnect();
	debug('Connecting to: %s:%s', [this.host, this.port]);

	// Stop the Uhura socket from keeping the event loop alive.
	if (this.socket && this.socket.unref) {
		this.socket.unref();
	}
}
util.inherits(Transport, Uhura.Client);
module.exports = Transport;

['update','instances','topCalls','reportError'].forEach(function (type) {
	Transport.prototype[type] = function (update, callback) {
		var self = this;
		self.getSession(function () {
			debug('sending(%s)', [type]);
			verbose('%s', [util.inspect(update)]);
			self.send(type, update, callback);
		});
	};
});

Transport.prototype.getSession = function (callback) {
	var self = this;

	// we already have a session ID
	if (self.get('sessionData')) {
		return callback();
	}

	// we are trying to retrieve the session already just come back later for it
	if (self.retrievingSession) {
		debug('delaying until session available');
		return this.once('newSession', function () {
			process.nextTick(function () {
				self.getSession(callback);
			});
		});
	}

	self.retrievingSession = true;

	this.once('newSession', function (err, session) {
		if (err) {
			console.log('NODEFLY ERROR: could not establish session\n', err);
			self.sessionId = null;
			self.retrievingSession = false;
			return;
		}

		debug('got session');
		self.agent.sessionId = session.sessionId;
		self.agent.appHash = session.appHash;
		self.retrievingSession = false;
		callback();
	});

	debug('requesting session');
	if (this.loopbackVersion) {
		debug('Loopback application detected');
	} else {
		debug('This is not a loopback application');
	}

	this.send('createSession', {
		appName: this.agent.appName
		, hostname: this.agent.hostname
		, agentVersion: this.agentVersion
		, key: this.agent.key
		, pid: process.pid
		, loopbackVersion: this.loopbackVersion
	});
};

Transport.init = function (options) {
	var transport = new Transport(options);
	transport.on('connect', function () {
		transport.getSession(function () {});
	});
	return transport;
};


var nf;

// Skip the express wrap, if we don't have domain support
var domain;
try { domain = require('domain'); }
catch (e) {
  exports.init = function () {
    global.nodefly.info('Error reporting is not available in this version of node');
  };
  exports.wrapExpress = function () {};
  return;
}

exports.init = function () {
  nf = global.nodefly;
  var d = domain.create();
  d.on('error', function (err) {
    d.exit();

    nf.emit('reportError', {
      ts: Date.now()
      , type: 'top-level'
      , stack: err.stack
    }, rethrow);

    // Make sure the error gets thrown even if the connection times out.
    // It's bad if the collector misses out on the error event but it's
    // infinitely worse to keep the application hanging in limbo.
    var timer = setTimeout(rethrow);
    if (timer.unref) {
      timer.unref();
    }

    function rethrow() {
      if (rethrow.thrown) return;
      rethrow.thrown = true;
      throw err;
    }
  });
  d.enter();
};

exports.wrapExpress = function (app) {
  var oldRoute = app._router.route;
  var first = true;

  // Hack to ensure the error handler middleware is always the last in the stack
  app.use(function (req, res, next) {
    if (first) {
      first = false;
      app.use(function (err, req, res, next) {
        if (err.tracked) return next(err);
        nf.emit('reportError', {
          ts: Date.now()
          , type: 'express'
          , command: req.command
          , stack: err.stack
        }, function () {
          err.tracked = true;
          next(err);
        });
      });
    }

    next();
  });

  app._router.route = function (method, path, callback) {
    // Wrap the next thing in a domain
    oldRoute.call(this, method, path, function (req, res, next) {
      req.command = req.method + ' ' + path;
      var d = req.domain = domain.create();
      d.add(req);
      d.add(res);
      d.on('error', next);
      d.run(next);
    });

    // Do actual route call
    oldRoute.apply(this, arguments);
  }
};
